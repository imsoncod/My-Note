## Collection

Collection에는 여러 원소들을 담을 수 있는 자료구조들이 구현되어있다.

배열의 정적인 성질을 보완할 수 있다. 

`배열은 초기 선언된 Size만큼만 데이터를 저장할 수 있지만 Collection의 자료구조들은 상황에따라 동적으로 Size가 조절된다`

이는 프로그램의 공간적인 효율성을 높여준다.

당연히, 구현되어있는 코드를 사용하기 때문에 자료구조를 직접구현할 필요가 없어 코딩시간을 줄이고 편하게 사용할 수 있다.

<br>

## List

중복을 허용하고 순서 보장이 요구되는 데이터를 보관할 때 사용한다.

인덱스로 데이터 접근이 가능하다.

빈 공간을 두지 않아 메모리 낭비를 최소화한다.

### ArrayList

List 인터페이스를 상속받은 클래스

크기가 가변적으로 변하는 선형리스트로 인덱스를 통해 내부 데이터를 관리한다.

크기가 변하지 않는 배열과 달리 데이터가 추가되었을 때 저장용량을 초과한다면 부족한 크기만큼 자동으로 저장용량이 늘어난다.

* 데이터 추가

  * add() 메소드 사용
  
  * index를 생략하면 ArrayList의 맨 뒤에 데이터를 추가한다
  
  * index를 사용하여 중간에 데이터를 추가하면 해당 인덱스부터 마지막 인덱스까지의 데이터들이 모두 1씩 뒤로 밀려난다

* 데이터 삭제

  * remove() 또는 clear() 메소드 사용
  
  * remove() 메소드를 이용하여 특정 인덱스의 데이터를 제거하면 **빈 공간이 생겨 연속성이 깨지게 되므로** 이를 막기 위해 해당 인덱스+1 부터 마지막 인덱스까지의 데이터들이 모두 1씩 앞으로 당겨진다
  
  * clear() 메소드는 ArrayList의 모든 데이터를 제거한다

* 데이터 조회
  
  * index를 알고 있다면 **O(1)의 빠른 속도**로 해당 데이터에 접근할 수 있다.

  * 즉 **Random Access**가 가능하다.

  ![image](https://user-images.githubusercontent.com/48934537/98201825-ee05f500-1f73-11eb-9d50-fb6102e0df2d.png)

### LinkedList

List 인터페이스를 상속받은 클래스

데이터필드(value)와 링크필드(next)로 이루어진 노드(Node)가 체인처럼 연결되어 있는 자료구조

각각의 노드들은 다음노드가 어디인지만을 기억하고있다.

시작노드를 저장하고 있는 헤더(Header)가 존재한다 + 마지막노드를 저장하고 있는 테일(Tail)이 존재한다.

* 데이터 추가

  * add(), addFirst(), addLast() 메소드 사용
  
  * 맨 앞에 데이터를 추가하는 addFirst()의 경우 Header의 Next값만 변경해주면 된다.
  
  * A와 C사이에 B를 추가한다고 가정하면
  
    * 삽입할 위치를 찾는다 <- 이 과정에서 **Sequential Access**가 이루어져 O(n)의 시간이 소요된다
    
    * A의 Next가 B를 가리키게 한다
    
    * B의 Next가 C를 가리키게 한다

* 데이터 삭제

  * remove(), removeFirst(), removeLast(), clear() 메소드 사용
  
  * 맨 앞에 데이터를 삭제하는 removeFirst()의 경우 Header의 Next값만 변경해주면 된다.
  
  * k 인덱스의 데이터를 삭제한다고 가정하면
  
    * 삭제할 k번째 노드를 찾는다 <- 이 과정에서 **Sequential Access**가 이루어져 O(n)의 시간이 소요된다
    
    * k-1번째 노드의 Next가 k+1번째 노드를 가리키게 한다
    
    * k번째 노드를 삭제한다

* 데이터 조회

  * 원하는 위치를 탐색하는 과정에서 **Sequential Access**가 이루어져 O(n)의 시간이 소요된다
  
  ![image](https://user-images.githubusercontent.com/48934537/98201825-ee05f500-1f73-11eb-9d50-fb6102e0df2d.png)

<br>

```
ArrayList는 데이터의 조회가 빈번할 때, LinkedList는 데이터의 삽입/삭제가 빈번할 때 사용한다
```

<br>

## Set

**중복을 허용하지 않고** 순서 보장이 필요없는 데이터를 보관할 때 사용한다.

인덱스로 데이터 접근이 불가능하다. 대신 반복자(Iterator)를 제공한다.

값을 추가하거나 삭제할때마다 데이터가 내부에 있는지/없는지를 판단해야하므로 속도가 List보다 느리다.

저장공간이 부족하면 List처럼 저장공간을 늘리는데 Set은 한칸씩 늘리지 않고 약 두 배로 저장공간을 늘린다(과부화 발생 우려)
  
따라서 저장할 데이터의 Size를 알고있다면 초기에 용량을 지정해주는것이 좋다

### HashSet

Set 인터페이스의 구현 클래스

자동으로 정렬을 해주지 않는다.

* 중복제거

  * 객체를 저장하기전의 해당 객체의 hashCode() 메소드를 통해 해시코드를 얻어낸 후 저장되어 있는 객체들의 해시코드와 비교하여 같은 해시코드가 있다면 equals() 메소드로
  두 객체를 비교해서 True가 반환되면 동일한 객체로 판단하고 중복저장을 하지 않는다
  
* 데이터 추가

  * add() 메소드 사용
  
* 데이터 삭제

  * remove(), clear() 메소드 사용
  
* 데이터 조회

  * Iterator의 next()메소드 사용
 
### TreeSet

Set 인터페이스의 구현 클래스

자동으로 정렬을 해준다. Default = 오름차순

이진탐색트리 구조로 이루어져 있다. 그 중에서도 성능을 향상시킨 레드-블랙 트리로 구현되어 있다.

레드-블랙 트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽자식으로, 큰 값을 가지는 노드는 오른쪽 자식으로 배치한다.
  
* 데이터 추가

  * add() 메소드 사용
  
* 데이터 삭제

  * remove(), clear() 메소드 사용
  
* 데이터 조회

  * Iterator의 next()메소드 사용

### LinkedHashSet

HashSet에서 순서를 보장하고 싶을때 사용한다.

**삽입된 순서**대로 데이터를 관리한다.

<br>

```
HashSet : 일반적으로 가장 속도가 빠른 Set

TreeSet : 자동으로 정렬이 되는 Set
 
LinkedHashSet : 삽입된 순서대로 데이터가 관리되는 Set
```

<br>

## Map

 * #### HashMap
 
 * #### HashTable
 
 * #### LinkedHashMap
 
 * #### TreeMap

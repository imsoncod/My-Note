## Collection

Collection에는 여러 원소들을 담을 수 있는 자료구조들이 구현되어있다.

배열의 정적인 성질을 보완할 수 있다. 

`배열은 초기 선언된 Size만큼만 데이터를 저장할 수 있지만 Collection의 자료구조들은 상황에따라 동적으로 Size가 조절된다`

이는 프로그램의 공간적인 효율성을 높여준다.

당연히, 구현되어있는 코드를 사용하기 때문에 자료구조를 직접구현할 필요가 없어 코딩시간을 줄이고 편하게 사용할 수 있다.

<br>

## List

중복을 허용하고 순서 보장이 요구되는 데이터를 보관할 때 사용한다.

인덱스로 데이터 접근이 가능하다.

빈 공간을 두지 않아 메모리 낭비를 최소화한다.

### ArrayList

List 인터페이스를 상속받은 클래스

크기가 가변적으로 변하는 선형리스트로 인덱스를 통해 내부 데이터를 관리한다.

크기가 변하지 않는 배열과 달리 데이터가 추가되었을 때 저장용량을 초과한다면 부족한 크기만큼 자동으로 저장용량이 늘어난다.

```
저장용량에 관하여

JAVA 8 기준 테스트 결과 ArrayList는 데이터삽입시 저장용량이 초과될때마다 부족한 크기만큼 저장용량을 늘리지 않았다.

실제로 old ArrayList Size 기준 1.5배 Size의 new ArrayList 사본을 만들었다.

이후 객체참조변수는 new ArrayList를 참조했고 old ArrayList 객체는 GC의 대상이 되었다.
```

* 데이터 추가

  * add() 메소드 사용
  
  * index를 생략하면 ArrayList의 맨 뒤에 데이터를 추가한다
  
  * index를 사용하여 중간에 데이터를 추가하면 해당 인덱스부터 마지막 인덱스까지의 데이터들이 모두 1씩 뒤로 밀려난다

* 데이터 삭제

  * remove() 또는 clear() 메소드 사용
  
  * remove() 메소드를 이용하여 특정 인덱스의 데이터를 제거하면 **빈 공간이 생겨 연속성이 깨지게 되므로** 이를 막기 위해 해당 인덱스+1 부터 마지막 인덱스까지의 데이터들이 모두 1씩 앞으로 당겨진다
  
  * clear() 메소드는 ArrayList의 모든 데이터를 제거한다

* 데이터 조회
  
  * index를 알고 있다면 **O(1)의 빠른 속도**로 해당 데이터에 접근할 수 있다.

  * 즉 **Random Access**가 가능하다.

  ![image](https://user-images.githubusercontent.com/48934537/98201825-ee05f500-1f73-11eb-9d50-fb6102e0df2d.png)

### LinkedList

List 인터페이스를 상속받은 클래스

데이터필드(value)와 링크필드(next)로 이루어진 노드(Node)가 체인처럼 연결되어 있는 자료구조

각각의 노드들은 다음노드가 어디인지만을 기억하고있다.

시작노드를 저장하고 있는 헤더(Header)가 존재한다 + 마지막노드를 저장하고 있는 테일(Tail)이 존재한다.

* 데이터 추가

  * add(), addFirst(), addLast() 메소드 사용
  
  * 맨 앞에 데이터를 추가하는 addFirst()의 경우 Header의 Next값만 변경해주면 된다.
  
  * A와 C사이에 B를 추가한다고 가정하면
  
    * 삽입할 위치를 찾는다 <- 이 과정에서 **Sequential Access**가 이루어져 O(n)의 시간이 소요된다
    
    * A의 Next가 B를 가리키게 한다
    
    * B의 Next가 C를 가리키게 한다

* 데이터 삭제

  * remove(), removeFirst(), removeLast(), clear() 메소드 사용
  
  * 맨 앞에 데이터를 삭제하는 removeFirst()의 경우 Header의 Next값만 변경해주면 된다.
  
  * k 인덱스의 데이터를 삭제한다고 가정하면
  
    * 삭제할 k번째 노드를 찾는다 <- 이 과정에서 **Sequential Access**가 이루어져 O(n)의 시간이 소요된다
    
    * k-1번째 노드의 Next가 k+1번째 노드를 가리키게 한다
    
    * k번째 노드를 삭제한다

* 데이터 조회

  * 원하는 위치를 탐색하는 과정에서 **Sequential Access**가 이루어져 O(n)의 시간이 소요된다
  
  ![image](https://user-images.githubusercontent.com/48934537/98201825-ee05f500-1f73-11eb-9d50-fb6102e0df2d.png)

<br>

```
Trade Off

ArrayList : 데이터의 조회가 빈번할 때 사용

LinkedList : 데이터의 삽입/삭제가 빈번할 때 사용한다
```

<br>

## Set

**중복을 허용하지 않고** 순서 보장이 필요없는 데이터를 보관할 때 사용한다.

인덱스로 데이터 접근이 불가능하다. 대신 반복자(Iterator)를 제공한다.

값을 추가하거나 삭제할때마다 데이터가 내부에 있는지/없는지를 판단해야하므로 속도가 List보다 느리다.

저장공간이 부족하면 List처럼 저장공간을 늘리는데 Set은 한칸씩 늘리지 않고 약 두 배로 저장공간을 늘린다(과부화 발생 우려)
  
따라서 저장할 데이터의 Size를 알고있다면 초기에 용량을 지정해주는것이 좋다

### HashSet

Set 인터페이스의 구현 클래스

자동으로 정렬을 해주지 않는다.

* 중복제거

  * 객체를 저장하기전의 해당 객체의 hashCode() 메소드를 통해 해시코드를 얻어낸 후 저장되어 있는 객체들의 해시코드와 비교하여 같은 해시코드가 있다면 equals() 메소드로
  두 객체를 비교해서 True가 반환되면 동일한 객체로 판단하고 중복저장을 하지 않는다
  
* 데이터 추가

  * add() 메소드 사용
  
* 데이터 삭제

  * remove(), clear() 메소드 사용
  
* 데이터 조회

  * Iterator의 next()메소드 사용
 
### TreeSet

Set 인터페이스의 구현 클래스

자동으로 정렬을 해준다. Default = 오름차순

이진탐색트리 구조로 이루어져 있다. 그 중에서도 성능을 향상시킨 레드-블랙 트리로 구현되어 있다.

레드-블랙 트리는 부모노드보다 작은 값을 가지는 노드는 왼쪽자식으로, 큰 값을 가지는 노드는 오른쪽 자식으로 배치한다.
  
* 데이터 추가

  * add() 메소드 사용
  
* 데이터 삭제

  * remove(), clear() 메소드 사용
  
* 데이터 조회

  * Iterator의 next()메소드 사용

### LinkedHashSet

HashSet에서 순서를 보장하고 싶을때 사용한다.

**삽입된 순서**대로 데이터를 관리한다.

<br>

```
HashSet : 일반적으로 가장 속도가 빠른 Set

TreeSet : 자동으로 정렬이 되는 Set
 
LinkedHashSet : 삽입된 순서대로 데이터가 관리되는 Set
```

<br>

## Map

Map은 List, Set과 다르게 Collection Class를 상속받지 않으며 구조도 조금 다르다.

key - value 구조로 데이터를 저장하는 형태를 가지며 수학의 함수 y=f(x)와 개념이 비슷하다.

순서를 유지하지는 않지만 key를 통해 value에 접근할 수 있다.
(이 부분은 JSON과 비슷한 것 같다)

key는 중복을 허용하지 않지만 value는 중복을 허용한다.

위 특징으로 인해 Map의 데이터를 중복을 허용하지 않는 데이터의 집합인 Set으로 가져올 수 있다.

key - value 는 중복될 일이 없으며 key 자체도 중복될 일이 없다.

따라서 entrySet(), keySet()메소드를 사용하여 모든 key - value 데이터 혹은 key만 별도로 Set으로 받을수 있다. 물론 key만 가지고도 value 까지 조회할 수 있지만 별도의 과정이 필요하므로 value까지 필요하다면 entrySet()을 사용하는 것이 효율적이다.

### HashMap

HashMap 클래스는 Map인터페이스의 구현 클래스이다.

대부분의 특징은 Map과 비슷하지만 내부적으로 Hash 알고리즘을 사용하여 검색에 특화되어있다.

대부분 O(1), 최악에도 O(N)의 시간복잡도를 보장한다.

### HashTable
 
HashTable 클래스는 Map인터페이스의 구현 클래스이다.

HashMap과 거의 동일하나 동기화 보장이 필요할때(멀티쓰레드) HashTable을 이용한다고 한다.
 
### LinkedHashMap

HashMap에서 순서를 보장하고 싶을때 사용한다.

**삽입된 순서**대로 Key가 보장된다.

궁금해서 찾아본 결과 HashMap과 성능의 차이는 크게 다르지 않다고 한다...
 
### TreeMap

TreeMap 클래스는 Map 인터페이스의 구현 클래스이다.

"Tree"이름과 걸맞게 이진탐색트리 구조로 이루어져 자세히는 레드-블랙트리로 이루어져있다.

따라서 데이터가 들어오면 자동으로 정렬을 수행해준다.

TreeMap의 레드-블랙트리는 부모노드의 키값기준으로 작은 키값은 왼쪽자식으로, 큰 키값은 오른쪽 자식으로 정렬한다. 이를 통해 트리가 편향되는 상황을 막을 수 있다.

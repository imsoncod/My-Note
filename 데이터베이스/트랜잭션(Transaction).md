## 트랜잭션(Transaction)

트랜잭션은 데이터베이스에서 **작업의 완정성**을 보장하기 위한 방법이다.

어떠한 논리적인 작업 Set을 묶어서 처리한다.

<br>

## 트랜잭션의 특징 ACID

### 원자성(Atomicity)

트랜잭션은 원자처럼 더 이상 쪼개지지 않는 프로그램 단위로 동작해야한다.

트랜잭션의 가장 중요한 성질이라고 볼 수 있다.

좀 더 쉽게 말하자면, 트랜잭션이 수행되는 도중 아무런 문제가 발생하지 않는다면 전체 작업이 수행되어야 하고

문제가 발생한다면 어떠한 작업도 수행되어서는 안된다. 이를 `all or nothing` 성질이라고도 부른다.

### 일관성(Consistency)

데이터베이스를 공부했던 사람이라면 너무나 당연하다고 여길 것 같은 성질이다.

트랜잭션이 수행 된 이후에도 데이터의 일관성이 보장되어야 한다 -> DB의 성질!

### 고립성(Isolation)

독립성이라고 보는게 더 이해가 쉬울 것 같다.

아무튼.. 각각의 트랜잭션은 서로 간섭없이 독릭접으로 수행되어야만 한다.

데이터 A와 이를 수정하는 트랜잭션 T1, T2가 있을 때, T1과 T2가 동시에 A에 접근하여 데이터가 훼손되는 일이 발생하면 안된다는 말이다.

`Thread-Safe`와 비슷한 내용인 것 같다. 데이터베이스에서는 `Lock`이라는 개념을 이용하여 동시접근을 제어한다고 한다.

### 지속성(Durability)

이것도 당연한 이야기이다 -> `데이터의 지속성`

트랜잭션이 정상적으로 종료된다면 작업의 결과가 데이터베이스에 영구적으로 저장되어야한다.

```
약간 깔끔하게 정리하자면

DBMS는 원자성을 유지하기 위해 회복 프로그램을 작동시킨다

DBMS는 일관성을 유지하기 위해 무결성 제약조건을 활용한다

DBMS는 고립성을 유지하기 위해 동시 접근 제어 알고리즘을 작동시킨다

DBMS는 지속성을 유지하기 위해 회복 프로그램을 작동시킨다

정도로 볼 수 있을 것 같다
```

<br>

## 트랜잭션의 아키텍처

![image](https://user-images.githubusercontent.com/48934537/99670200-82fc0880-2ab3-11eb-8745-e506b1fc4ed7.png)

이해하기 정말 쉽다! 하나만 설명하자면 부분완료(partially committed)는 `COMMIT`요청을 받았지만 아직 `COMMIT`하지는 않은 상태이다.

<br>

## Lock

위에서 잠깐 나왔던 내용이다.

Lock은 DBMS의 고립성을 유지하기 위한 동시 접근 제어 방법이다.

트랜잭션이 읽기작업을 할 때 사용하는 공유락(LS)과 쓰기작업을 할 때 사용하는 배타락(LX)로 나누어진다.

일반적으로 동시 접근 제어는 한 개의 데이터에 동시에 쓰기작업을 할 때 발생하는 `Lost Update`를 방지하기 위해 사용한다.

또한, 트랜잭션이 데이터에 대한 락을 허용받지 못하면 대기 상태에 빠지게 되고 이는 `교착상태(DeadLock)`로 이어질 수 있다.

```
교착상태(DeadLock)의 개념

트랜잭션 T1, T2와 데이터 A, B가 있을 때 T1, T2가 각각 A,B에 LX를 걸고 크로스 형식으로 B,A에도 LX를 걸었다고 가정해보자.

각자 본인 데이터인 A와 B에 대해서는 Lock을 흭득할 수 있다.

하지만 T1이 A를, T2가 B에 대한 Lock을 흭득한 상황에서 서로의 데이터에 Lock을 요청하였기 때문에 무한 대기상태에 빠지게 된다.

(Lock을 흭득하는 과정에서 싸이클이 생성되었다고 볼 수 있다)

이 경우, 일반적으로 DBMS는 T1,T2중 하나의 작업을 강제로 중단시켜 다른 하나의 작업은 정상적으로 수행되게끔 한다.
```

<br>

## 회복

트랜잭션 수행 중간에 장애가 발생할경우, 모든 작업이 취소되고 수정된 데이터가 모두 원상태로 복구된다.

어떠한 원리로 이루어지는지 찾아보니 `Log`파일을 사용한다고 한다.

DBMS는 트랜잭션의 작업을 추적하는 `Log`파일을 사용하여 데이터를 회복시킨다.

```
Log 파일의 형식은 다음과 같다.

<트랜잭션번호, 작업내용, 데이터 항목 이름, 변경 전 값, 변경 후 값>
```

DBMS는 이 `Log`파일을 참조하여 트랜잭션의 재실행(REDO), 취소(UNDO) 여부를 결정한다.

`REDO는 START와 COMMIT이 둘 다 있는 경우이고 UNDO는 START만 있는 경우이다`

<br>

## 회복 방법

### 지연 갱신 방법

트랜잭션이 부분완료 상태에 이르기까지 발생한 모든 변경 내용을 `Log`에만 저장한다 -> `Log 의존도 높음`

말 그대로 COMMIT(저장)을 `지연`하는 방법이다.

장애가 발생할 경우 COMMIT을 하지 않았기 때문에 UNDO를 하지 않아도 된다.

### 즉시 갱신 방법

트랙잭션이 부분완료 상태에 이르지 않아도 작업중 발생되는 모든 변경내용을 `Log'뿐만아니라 데이터베이스에도 반영한다.

장애가 발생할 경우 REDO와 UNDO를 모두 해야한다.

### 체크포인트 방법

체크포인트를 이용하면 `Log`를 이용한 회복 방법이 좀 더 간단해진다.

```
체크포인트에서는 작업에 대한 Log기록과 데이터베이스 저장이 이루어진다

따라서 3가지 경우로 나눌수 있는데

체크포인트 이전에 COMMIT이 있는 경우에는 작업 내용이 이미 데이터베이스에 반영되었기 때문에 아무런 작업을 하지 않아도 된다

체크포인트 이후에 COMMIT이 있는 경우 작업 내용이 데이터베이스에 반영되지 않았음으로 REDO를 해야한다

체크포인트 이후에 COMMIT이 없는 경우 즉시 갱신기법을 사용했을 경우 UNDO, 지연 갱신기법을 사용했을 경우 아무것도 하지 않아도 된다.

## 인덱스(Index)

인덱스는 데이터베이스에서 조회 및 검색을 빠르게 하기위한 방법 혹은 기술이라고 볼 수 있다.

주로 기본키를 기준으로 자동생성되며 별도로 인덱스를 생성할수도 있다.

<br>

### 왜 인덱스는 조회 및 검색이 빠를까?

우리는 보통 인덱스라는 단어를 책의 목차에서 많이 확인할 수 있다.

예시로, 데이터베이스 책에서 트랜잭션이라는 내용을 찾는다고 해보자.

앞에서 부터 한 쪽씩 순차적으로 찾을수도 있지만 이는 상당히 비효율적인 방법이다.

반면에, 목차를 이용한다면 어떨까? 목차에서 트랜잭션이라는 단어를 찾아 해당 페이지를 찾아간다면

전자보다 훨씬 빠르게 원하는 내용을 찾을 수 있을것이다.

더불어 목차가 "가나다"순으로 정렬까지 되어있다면 우리는 훨씬 더 빠르게 원하는 내용을 찾을 수 있을 것이다.

이것이 인덱스를 사용하는 이유이자 인덱스의 장점이다.

인덱스는 컬럼값과 컬럼값이 위치하는 레코드의 주소 쌍으로 이루어져 있고 항상 정렬된 상태를 유지하여

어떠한 조건에 부합하는 내용을 찾을 때 빠른속도로 해당 내용이 있는 레코드에 접근 할 수 있는 것이다.

<br>

### 왜 모든필드에 인덱스를 생성하지 않을까?

인덱스는 별도로 (컬럼값 - 레코드 주소값)으로 이루어진 테이블 형태로 관리가 된다.

즉, 자원을 사용한다고 볼 수 있다. 

따라서, 인덱스의 무분별한 사용은 성능에 부정적인 영향을 가져올 수 있다.

<br>

### 왜 인덱스는 B+Tree 구조로 되어 있을까?

이 질문은 HashTable과 연관지어 생각해보겠다.

HashTable은 데이터 조회 측면에서 시각복잡도가 O(1)인 매우 빠르고 강력한 알고리즘이다.

그렇다면 왜 HashTable을 사용하지 않을까?

SQL문에서는 Where절을 사용할 때 동등연산(=)과 더불어 부등호를(<>) 이용한 비교연산도 사용한다.

HashTable의 경우 동등연산에만 특화되어 있어 인덱스의 자료구조로는 적합하지 않다.

### 왜 인덱스는 추가,삭제,수정 작업에서 성능이 좋지 않을까?

추가(INSERT)작업의 경우 데이터를 추가하면 테이블에 추가되는 것 뿐만아니라 인덱스 또한 생성해야한다.

삭제(DELETE)작업의 경우 데이터를 삭제하면 테이블에서는 삭제되지만 인덱스 데이터는 그대로 남아있다.

잘못될경우 실제 데이터는 10만개이나 인덱스는 100만개가 될 수도 있다.

수정(UPDATE)작업의 경우 추가,삭제 작업에서 생기는 문제점을 동시에 수반한다.
